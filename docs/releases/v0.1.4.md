# Gonimbus v0.1.4 Release Notes

**Release Date**: 2026-01-19
**Status**: Path-Scoped Index Builds + Managed Jobs for Enterprise Scale

## Overview

Gonimbus v0.1.4 delivers two major capabilities for enterprise-scale index operations:

1. **Path-Scoped Index Builds** (`build.scope`) - the primary lever for reducing provider listing costs on date-partitioned buckets, eliminating 99%+ of wasted enumeration
2. **Managed Index Build Jobs** - durable job tracking and background execution for long-running builds

Together, these features make Gonimbus practical for multi-hour index builds on huge buckets. This release completes the "scope partitions" work previewed in v0.1.3 and establishes a three-tier model for enterprise indexing:

| Tier                    | Mechanism                           | Controls               |
| ----------------------- | ----------------------------------- | ---------------------- |
| **1. Prefix Sharding**  | `base_uri` + `build.match.includes` | Which prefixes to list |
| **2. Ingest Filtering** | `build.match.filters`               | Which objects to store |
| **3. Path Scoping**     | `build.scope`                       | Prefix plan generation |

## The Problem

Large enterprise buckets often contain years of date-partitioned data:

```
s3://bucket/data/{store}/{device}/{YYYY-MM-DD}/{files}
```

When operators only need the last 30 days, traditional crawl approaches still enumerate the entire history:

- **Without scope**: List 32M objects, match 350K (99% wasted)
- **With scope**: List 185K objects, match 185K (0% wasted)

## The Solution: `build.scope`

Add a `build.scope` block to your index manifest to generate an explicit prefix plan:

```yaml
build:
  scope:
    type: date_partitions
    discover:
      segments:
        - index: 0 # discover store IDs
        - index: 1 # discover device IDs
    date:
      segment_index: 2
      format: "2006-01-02"
      range:
        after: "2025-12-15" # inclusive
        before: "2026-01-01" # exclusive
```

The scope compiler:

1. Discovers variable segments via delimiter listing
2. Expands the date range to concrete prefixes
3. Crawls only those prefixes

## Scope Types

### `prefix_list`

Explicit prefixes when you know exactly what to list:

```yaml
build:
  scope:
    type: prefix_list
    prefixes:
      - "store-001/device-A/2025-12-15/"
      - "store-001/device-A/2025-12-16/"
```

### `date_partitions`

Dynamic prefix generation from date ranges:

```yaml
build:
  scope:
    type: date_partitions
    discover:
      segments:
        - index: 0 # discover at segment 0
          allow: ["store-001", "store-002"] # optional filter
    date:
      segment_index: 1 # date is segment 1
      format: "2006-01-02" # folder format
      range:
        after: "2025-12-01"
        before: "2026-01-01"
```

### `union`

Combine multiple scopes:

```yaml
build:
  scope:
    type: union
    scopes:
      - type: prefix_list
        prefixes: ["hot-data/"]
      - type: date_partitions
        # ...
```

## Dry-Run: Preview the Scope Plan

Before executing a build, preview the prefix plan:

```bash
gonimbus index build --job index-manifest.yaml --dry-run
```

Output shows:

- Prefix count and sample prefixes
- Any guardrail warnings
- Identity hash that will be used

## Guardrails

v0.1.4 adds safety guardrails for scope expansion:

- **Warning threshold**: Alerts when prefix count exceeds expected bounds
- **Soft-delete skipped**: Scoped builds skip soft-delete by default (partial coverage)
- **Identity isolation**: Scope config is hashed into the IndexSet identity

---

## Managed Index Build Jobs

Index builds on enterprise buckets can run for hours. Managing them with shell primitives (`&`, `nohup`, `screen`) is brittle for multi-hour jobs, concurrent builds, and AI agent orchestration.

v0.1.4 adds first-class job management with durable state and background execution.

### Usage

```bash
# Start a managed background build (returns job id immediately)
gonimbus index build --background --job index.yaml --name nightly-sweep

# Monitor running and recent jobs
gonimbus index jobs list
gonimbus index jobs status <job_id>

# Stream logs from a running job
gonimbus index jobs logs <job_id> --follow

# Safe cancellation
gonimbus index jobs stop <job_id>

# Clean up old job records
gonimbus index jobs gc --max-age 168h
```

### Key Features

- **Durable job registry**: Jobs persist under app data dir (`jobs/index-build/<job_id>/`)
- **Background execution**: `--background` spawns a managed child process and returns immediately
- **Safe cancellation**: SIGTERM triggers graceful context cancellation; SIGKILL fallback
- **Log capture**: stdout/stderr streamed to per-job log files
- **Deduplication**: `--dedupe` prevents duplicate running jobs for the same manifest
- **JSON output**: All job commands support `--json` for scripting and agent integration
- **Short ID resolution**: `jobs status` accepts unambiguous ID prefixes for convenience

### Job States

`queued` → `running` → `success` | `partial` | `failed`

Jobs can also be `stopping` (graceful shutdown in progress) or `stopped` (cancelled).

### On-Disk Layout

Job records are stored under the app data directory:

```
<data_dir>/jobs/index-build/<job_id>/
├── job.json      # Job metadata and state
├── stdout.log    # Captured stdout
└── stderr.log    # Captured stderr
```

---

## Performance Impact

Testing with enterprise date-partitioned data:

| Configuration       | Objects Found | Objects Matched | Build Time |
| ------------------- | ------------- | --------------- | ---------- |
| 5-store full month  | 15.9M         | 150K            | ~3 min     |
| 5-store scoped 17d  | 78K           | 78K             | ~20 sec    |
| 15-store full month | 32M           | 350K            | ~3 min     |
| 15-store scoped 17d | 185K          | 185K            | ~30 sec    |

Key metrics:

- **99.5% reduction** in objects listed
- **~10x faster** build completion
- **Zero wasted enumeration** (`objects_found ≈ objects_matched`)

## Changes

### Added

**Path Scoping (`build.scope`):**

- Scope types: `prefix_list`, `date_partitions`, `union`
- Scope compiler generates explicit prefix plans
- Delimiter listing for segment discovery
- `--dry-run` previews scope plan before execution
- Scope config included in IndexSet identity hash
- Guardrails for prefix expansion warnings

**Index Job Management:**

- Job registry with durable on-disk persistence (`pkg/jobregistry/`)
- `gonimbus index build --background` for managed background execution
- `gonimbus index jobs list/status` with JSON output support
- `gonimbus index jobs stop` for safe cancellation
- `gonimbus index jobs logs` for streaming log access
- `gonimbus index jobs gc` for cleaning up old job records
- `--dedupe` flag prevents duplicate running jobs for same manifest
- Short ID prefix resolution for convenience

**Provider Capability Contract:**

- ADR-0003: Defines prefix listing and delimiter listing requirements
- Error classification for partial run handling
- Provider-agnostic scope compilation

### Changed

- `--after` filter is now inclusive (was exclusive) for consistency with date range semantics
- Soft-delete skipped by default for scoped builds (partial coverage)
- Index identity now includes scope configuration hash

### Fixed

- Tree traversal callback is now safe under parallel execution

### Documentation

- Enterprise indexing workflow guide with three-tier model (`docs/user-guide/index.md`)
- Indexing architecture with scope concepts (`docs/architecture/indexing.md`)
- ADR-0003: Index build provider capabilities (`docs/architecture/adr/ADR-0003-*.md`)

## Upgrade Notes

No breaking changes from v0.1.3. Upgrade with:

```bash
go install github.com/3leaps/gonimbus/cmd/gonimbus@v0.1.4
```

**Migration Tips:**

- Existing manifests work unchanged (no `build.scope` = full coverage)
- Add `build.scope` when you need to reduce listing costs on date-partitioned data
- Use `--dry-run` to preview scope plans before committing to builds
- Scoped builds create new IndexSets (scope changes identity)

## When to Use Scope

Use `build.scope.date_partitions` when:

- Data is partitioned by date in the path structure
- You only need a recent time window (e.g., last 30-90 days)
- The bucket has significant historical data you don't need
- Build time or provider API costs are concerns

Use `build.scope.prefix_list` when:

- You have a fixed, known set of prefixes
- Prefixes are not date-based but still sparse

## What's Next

v0.1.5 will focus on:

- Incremental scope expansion (append new date ranges to existing indexes)
- GCS provider support (fast-follow)

## Contributors

- Dave Thompson (@3leapsdave)

## License

Apache License 2.0 - see [LICENSE](../../LICENSE)
